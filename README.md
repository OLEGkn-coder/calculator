# Parser-calculator, autor Oleh Modhenskyi

## Parsing a mathemtical expression

### В парсері ми будемо парсити математичний вираз на його основні складові: числа, знаки, дужки. Далі будемо обраховувати цe враховуючи пріоритет знаків та дужок за допомогою цих функцій: 
1. 
```rust 
fn check_bracket(input: &String) -> i32{}
```
- Ця функція приймає наший вхідий рядок та перевіряє його на наявність дужок, якщо вони є то беремо вираз всередині них, обраховюємо та замінюємо вираз в дужках значенням яке вийшло після обчислень.

2. 
```rust 
fn parse_number(input: &String) -> Vec<i32> {}
```
- Ця функція використовується для парсингу математичного виразу, щоб видобути числа для подальшого обчислення. Для цього ми замінюємо всі знаки на пробіли і потім парсимо по пробілам наші числв.
- Приклад
```rust
assert_eq!(parse_number(&"2+3*5-25".to_string()), vec![2, 3, 5, 25]);
```

3. 
```rust 
fn parse_sign(input: &String) -> Vec<char> {}
```
- Ця функція використовується для того, щоб видобути оператори для подальшого обчислення. Для цього ми просто використовуємо метод filtre щоб відфільтрувати всі знаки від інших символів та чисел.
- Приклад
```rust
 assert_eq!(parse_number(&"2+3*5-25".to_string()), vec![+, *, -]);
```

4. 
```rust 
fn calc(mut number: Vec<i32>, ch: Vec<char>) -> i32 {}
```

- Основна функція обрахунку - після того як ми отримали наші числа та оператори ми обраховуємо загальне значення виразу й повератємо його.. Спочатку ми шукаємо "*" та "/" щоб виконати ці дії, обчислюємо число яке стоїть на місці(a) індекса знака "*" або "/" з a+1 та отримуємо значення.
- Приклад
```rust
 assert_eq!(parse_number(&"2+3*5-25".to_string()), -8);
```



